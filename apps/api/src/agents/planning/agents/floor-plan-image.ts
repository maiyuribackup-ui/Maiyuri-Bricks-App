/**
 * Floor Plan Image Generator Agent (Agent 13)
 *
 * Generates AI images of floor plans and architectural visualizations
 * using either:
 * 1. CAD Service Backend Bridge (preferred for precision)
 * 2. Gemini's image generation capability (fallback)
 *
 * This is the final stage of the Eco-Vastu Floor Plan Generator pipeline.
 * Takes render prompts from the Visualization Agent and produces actual images.
 *
 * Architecture:
 * - Backend Bridge Mode: TS Pipeline → Python CAD Engine → DXF + AI Rendering
 * - Direct Mode: TS Pipeline → Gemini Image Generation
 *
 * Responsibilities:
 * - Generate 2D floor plan image (CAD wireframe + AI enhancement)
 * - Generate 3D courtyard rendering
 * - Generate 3D exterior view
 * - Generate 3D interior view
 *
 * Guardrails:
 * - Uses Gemini image generation API
 * - CAD service for precision floor plans
 * - Retries on transient failures
 * - Returns placeholder data on critical failures
 */

import type { DesignContext } from '../types/design-context';
import type {
  AgentResult,
  TokenUsage,
  AgentError,
} from '../types/agent-result';
import type {
  FloorPlanImageInput,
  FloorPlanImageOutput,
  GeneratedImageData,
} from '../types/contracts';
import { retryWithBackoff, type RetryConfig } from '../utils/retry';
import { logger } from '../utils/logger';
import { generateImage } from '../../../cloudcore/services/ai/gemini';
import { getCadService, type CadRenderResult } from '../../../services/cad-service';

/**
 * Agent configuration
 */
interface FloorPlanImageConfig {
  maxRetries: number;
  baseDelayMs: number;
  /** Which images to generate */
  imagesToGenerate: ('floorPlan' | 'courtyard' | 'exterior' | 'interior')[];
  /** Generate images in parallel */
  parallel: boolean;
  /** Use CAD Backend Bridge for floor plan generation */
  useCadService: boolean;
  /** CAD service URL (defaults to localhost:8000) */
  cadServiceUrl?: string;
  /** Rendering style for CAD service */
  cadRenderStyle: 'professional' | 'blueprint' | 'sketch';
  /** Enable AI enhancement in CAD service */
  cadAiRender: boolean;
}

const DEFAULT_CONFIG: FloorPlanImageConfig = {
  maxRetries: 2,
  baseDelayMs: 2000,
  imagesToGenerate: ['floorPlan'], // Default to just floor plan for speed
  parallel: false, // Sequential for stability
  useCadService: true, // Use Backend Bridge by default
  cadServiceUrl: process.env.CAD_ENGINE_URL || 'http://localhost:8000',
  cadRenderStyle: 'professional',
  cadAiRender: true,
};

/**
 * Floor Plan Image Generator Agent
 *
 * Uses Gemini image generation to create floor plan visualizations.
 */
export class FloorPlanImageAgent {
  readonly agentName = 'floor-plan-image' as const;
  private config: FloorPlanImageConfig;

  constructor(config: Partial<FloorPlanImageConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Execute floor plan image generation
   */
  async execute(
    input: FloorPlanImageInput,
    context: DesignContext
  ): Promise<AgentResult<FloorPlanImageOutput>> {
    const startTime = Date.now();
    const agentLogger = logger.child({
      agentName: this.agentName,
      sessionId: context.sessionId,
    });

    try {
      agentLogger.agentStart(this.agentName, context.sessionId);

      // Step 1: Validate input
      this.validateInput(input);

      // Step 2: Generate images
      const output: FloorPlanImageOutput = {
        metadata: {
          model: this.config.useCadService ? 'cad-service + gemini' : 'gemini-2.0-flash-exp',
          totalImagesGenerated: 0,
          generationTime: 0,
        },
      };

      // Step 2a: Use CAD Backend Bridge for floor plan if enabled
      if (this.config.useCadService && this.config.imagesToGenerate.includes('floorPlan')) {
        try {
          const cadResult = await this.generateFloorPlanViaCadService(input, context);
          if (cadResult) {
            output.floorPlan = cadResult;
            output.metadata.totalImagesGenerated++;
            agentLogger.info('Floor plan generated via CAD Backend Bridge', {
              aiEnhanced: true,
              totalArea: input.rooms?.reduce((sum, r) => sum + r.area_sqft, 0) || 0,
            });
          }
        } catch (cadError) {
          agentLogger.warn('CAD service failed, falling back to direct Gemini generation', {
            error: cadError instanceof Error ? cadError.message : String(cadError),
          });
          // Will fall through to direct Gemini generation below
        }
      }

      // Filter out floor plan if already generated by CAD service
      const remainingImages = this.config.imagesToGenerate.filter(
        (type) => !(type === 'floorPlan' && output.floorPlan)
      );

      if (this.config.parallel && remainingImages.length > 0) {
        // Generate in parallel for speed
        const results = await Promise.allSettled(
          remainingImages.map((imageType) =>
            this.generateSingleImage(imageType, input, context)
          )
        );

        results.forEach((result, index) => {
          const imageType = remainingImages[index];
          if (result.status === 'fulfilled' && result.value) {
            output[imageType] = result.value;
            output.metadata.totalImagesGenerated++;
          }
        });
      } else if (remainingImages.length > 0) {
        // Generate sequentially for stability
        for (const imageType of remainingImages) {
          try {
            const image = await this.generateSingleImage(imageType, input, context);
            if (image) {
              output[imageType] = image;
              output.metadata.totalImagesGenerated++;
            }
          } catch (error) {
            agentLogger.warn(`Failed to generate ${imageType} image`, { error });
          }
        }
      }

      output.metadata.generationTime = Date.now() - startTime;

      // Calculate token usage (estimate based on prompt length)
      const promptLength = Object.values(input.renderPrompts)
        .filter(Boolean)
        .join('').length;
      const tokensUsed: TokenUsage = {
        input: Math.round(promptLength / 4),
        output: output.metadata.totalImagesGenerated * 100, // Estimate
        total: 0,
      };
      tokensUsed.total = tokensUsed.input + tokensUsed.output;

      const executionTimeMs = Date.now() - startTime;

      agentLogger.agentComplete(
        this.agentName,
        context.sessionId,
        executionTimeMs,
        0
      );

      // Check if at least one image was generated
      if (output.metadata.totalImagesGenerated === 0) {
        return {
          success: false,
          agentName: this.agentName,
          executionTimeMs,
          tokensUsed,
          error: {
            code: 'NO_IMAGES_GENERATED',
            message: 'Failed to generate any images',
            retryable: true,
          },
          openQuestions: [],
          assumptions: [],
        };
      }

      return {
        success: true,
        agentName: this.agentName,
        executionTimeMs,
        tokensUsed,
        data: output,
        openQuestions: [],
        assumptions: [],
        meta: {
          model: 'gemini-2.0-flash-exp',
          imagesGenerated: output.metadata.totalImagesGenerated,
          generationTimeMs: output.metadata.generationTime,
        },
      };
    } catch (error) {
      const executionTimeMs = Date.now() - startTime;
      const err = error instanceof Error ? error : new Error(String(error));

      agentLogger.agentFailed(this.agentName, context.sessionId, err);

      const agentError: AgentError = {
        code: 'FLOOR_PLAN_IMAGE_ERROR',
        message: err.message,
        retryable: this.isRetryable(error),
      };

      return {
        success: false,
        agentName: this.agentName,
        executionTimeMs,
        tokensUsed: { input: 0, output: 0, total: 0 },
        error: agentError,
        openQuestions: [],
        assumptions: [],
      };
    }
  }

  /**
   * Validate input
   */
  private validateInput(input: FloorPlanImageInput): void {
    if (!input.renderPrompts) {
      throw new Error('Render prompts are required for image generation');
    }

    const hasAnyPrompt =
      input.renderPrompts.floorPlan ||
      input.renderPrompts.courtyard ||
      input.renderPrompts.exterior ||
      input.renderPrompts.interior;

    if (!hasAnyPrompt) {
      throw new Error('At least one render prompt is required');
    }
  }

  /**
   * Generate a single image
   */
  private async generateSingleImage(
    imageType: 'floorPlan' | 'courtyard' | 'exterior' | 'interior',
    input: FloorPlanImageInput,
    context: DesignContext
  ): Promise<GeneratedImageData | null> {
    const prompt = input.renderPrompts[imageType];
    if (!prompt) {
      return null;
    }

    // Enhance prompt with additional context
    const enhancedPrompt = this.enhancePrompt(imageType, prompt, input, context);

    // Use retry wrapper
    const retryConfig: Partial<RetryConfig> = {
      maxRetries: this.config.maxRetries,
      baseDelayMs: this.config.baseDelayMs,
    };

    try {
      const result = await retryWithBackoff(
        () => generateImage(enhancedPrompt),
        retryConfig
      );

      if (result.success && result.data && result.data.images.length > 0) {
        const image = result.data.images[0];
        return {
          base64Data: image.base64Data,
          mimeType: image.mimeType,
          generatedAt: new Date(),
        };
      }

      return null;
    } catch (error) {
      console.error(`Failed to generate ${imageType} image:`, error);
      return null;
    }
  }

  /**
   * Enhance prompt with additional architectural context
   *
   * IMPORTANT: Includes dimension accuracy requirements to ensure
   * AI-generated images display exact measurements as specified.
   */
  private enhancePrompt(
    imageType: 'floorPlan' | 'courtyard' | 'exterior' | 'interior',
    basePrompt: string,
    input: FloorPlanImageInput,
    context: DesignContext
  ): string {
    // Add image type specific prefixes for better results
    const prefixes: Record<string, string> = {
      floorPlan:
        'Professional architectural floor plan drawing. Clean 2D top-down view. ',
      courtyard:
        'Photorealistic architectural visualization. 3D interior courtyard view. ',
      exterior:
        'Photorealistic architectural visualization. 3D exterior facade view. ',
      interior:
        'Photorealistic architectural visualization. 3D interior living space. ',
    };

    // Add style suffixes
    const suffix =
      ' High quality, professional architectural rendering. Traditional Tamil Nadu residential style with modern eco-design elements.';

    // CRITICAL: Dimension accuracy requirements for floor plans
    let dimensionAccuracyBlock = '';
    if (imageType === 'floorPlan') {
      dimensionAccuracyBlock = `

CRITICAL DIMENSION ACCURACY REQUIREMENTS:
- All dimensions MUST be displayed EXACTLY as specified - NO rounding or approximation
- Header text MUST show exact plot dimensions as provided
- Room labels MUST include exact dimensions in feet-inches format
- MANDATORY: Include scale ruler for verification`;
    }

    // Include room dimensions if available for floor plan
    let dimensionContext = '';
    if (imageType === 'floorPlan' && input.rooms && input.rooms.length > 0) {
      const roomSummary = input.rooms
        .slice(0, 8) // Include more rooms for accuracy
        .map((r) => `${r.name} (MUST show exactly ${r.width}'×${r.depth}')`)
        .join(', ');
      dimensionContext = ` Rooms: ${roomSummary}.`;
    }

    // Include plot dimensions if available - with MUST show exactly
    let plotContext = '';
    if (input.plotDimensions) {
      plotContext = ` MUST show exactly ${input.plotDimensions.width}'×${input.plotDimensions.depth}' ${input.plotDimensions.unit || 'feet'} plot in header.`;
    }

    // Include orientation
    let orientationContext = '';
    if (input.orientation) {
      orientationContext = ` ${input.orientation.charAt(0).toUpperCase() + input.orientation.slice(1)}-facing entrance.`;
    }

    return `${prefixes[imageType] || ''}${basePrompt}${dimensionAccuracyBlock}${dimensionContext}${plotContext}${orientationContext}${suffix}`;
  }

  /**
   * Generate floor plan via CAD Backend Bridge
   *
   * This method calls the Python CAD Engine to generate a precision wireframe,
   * then optionally applies AI enhancement via Gemini.
   */
  private async generateFloorPlanViaCadService(
    input: FloorPlanImageInput,
    context: DesignContext
  ): Promise<GeneratedImageData | null> {
    const cadService = getCadService({
      baseUrl: this.config.cadServiceUrl,
    });

    // Check if CAD service is available
    const isAvailable = await cadService.isAvailable();
    if (!isAvailable) {
      logger.warn('CAD service not available, will fall back to direct Gemini generation');
      return null;
    }

    // Build input for CAD service from FloorPlanImageInput
    const cadInput = {
      rooms: (input.rooms || []).map((r) => ({
        id: r.id || r.name.toLowerCase().replace(/\s+/g, '-'),
        name: r.name,
        type: r.type || 'room',
        width: r.width,
        depth: r.depth,
        area_sqft: r.area_sqft,
        zone: r.zone || 'private',
        adjacent_to: r.adjacentTo || [],
      })),
      wall_system: input.wallSystem || {
        external_thickness_inches: 9,
        internal_thickness_inches: 4.5,
        material: 'Burnt clay brick masonry with cement mortar 1:6',
        load_bearing_walls: [],
      },
      staircase: input.staircase || null,
      plumbing_strategy: input.plumbingStrategy
        ? {
            wet_areas_grouped: input.plumbingStrategy.wet_areas_grouped,
            shaft_positions: input.plumbingStrategy.shaft_positions,
            sewer_connection: (input.plumbingStrategy.sewer_connection || 'south') as 'north' | 'south' | 'east' | 'west',
          }
        : null,
      ventilation_shafts: input.ventilationShafts || [],
      expansion_provision: input.expansionProvision
        ? {
            direction: (input.expansionProvision.direction || 'south') as 'north' | 'south' | 'east' | 'west',
            type: input.expansionProvision.type,
            notes: input.expansionProvision.notes,
          }
        : null,
      plot_dimensions: input.plotDimensions
        ? {
            width: input.plotDimensions.width,
            depth: input.plotDimensions.depth,
            unit: input.plotDimensions.unit || 'feet',
          }
        : null,
      orientation: (input.orientation || 'north') as 'north' | 'south' | 'east' | 'west',
      style: this.config.cadRenderStyle,
      ai_render: this.config.cadAiRender,
      background: 'white' as const,
      // Vastu zones for room placement algorithm
      vastu_zones: input.vastuZones || null,
      // Road side for entrance/verandah placement
      road_side: (input.roadSide || 'south') as string,
    };

    // Call CAD service
    const result = await cadService.renderEngineeringPlan(cadInput);

    if (!result.success) {
      logger.warn('CAD service render failed', { message: result.message });
      return null;
    }

    // Use AI-rendered image if available, otherwise use wireframe
    const imageBase64 = result.ai_rendered_base64 || result.wireframe_base64;

    if (!imageBase64) {
      logger.warn('CAD service returned no image data');
      return null;
    }

    return {
      base64Data: imageBase64,
      mimeType: 'image/png',
      generatedAt: new Date(),
    };
  }

  /**
   * Check if error is retryable
   */
  private isRetryable(error: unknown): boolean {
    if (error instanceof Error) {
      const message = error.message.toLowerCase();
      if (
        message.includes('rate limit') ||
        message.includes('timeout') ||
        message.includes('temporarily')
      ) {
        return true;
      }
    }
    return false;
  }
}

/**
 * Factory function to create FloorPlanImageAgent
 */
export function createFloorPlanImageAgent(
  config?: Partial<FloorPlanImageConfig>
): FloorPlanImageAgent {
  return new FloorPlanImageAgent(config);
}

/**
 * Create agent configured to generate all images
 */
export function createFullVisualizationAgent(): FloorPlanImageAgent {
  return new FloorPlanImageAgent({
    imagesToGenerate: ['floorPlan', 'courtyard', 'exterior', 'interior'],
    parallel: true,
  });
}
